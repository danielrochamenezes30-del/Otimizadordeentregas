<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organizador de Entregas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%233b82f6'%3E%3Cpath fill-rule='evenodd' d='M5.478 5.558A1.5 1.5 0 0 1 6.912 4.5H9A.75.75 0 0 1 9.75 5.25v2.53A1.496 1.496 0 0 1 8.25 9H6.912a1.5 1.5 0 0 1-1.434-.942l-2.43-6a.75.75 0 0 1 .942-1.026l1.488.638ZM12.75 5.25A.75.75 0 0 0 12 6v13.5a.75.75 0 0 0 .75.75h4.5a.75.75 0 0 0 .75-.75V6a.75.75 0 0 0-.75-.75h-4.5Z' clip-rule='evenodd' /%3E%3Cpath d='m4.512 11.558 2.43 6A1.5 1.5 0 0 0 8.376 19.5H9a.75.75 0 0 0 .75-.75v-2.53a1.496 1.496 0 0 0-1.5-1.47H6.876a1.5 1.5 0 0 0-1.434.942l-2.43 6a.75.75 0 0 0 .942 1.026l1.488-.638ZM21.75 6.75A.75.75 0 0 0 21 6H19.5a.75.75 0 0 0-.75.75v13.5a.75.75 0 0 0 1.5 0V7.5H21a.75.75 0 0 0 .75-.75Z' /%3E%3C/svg%3E">

    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f1f5f9; /* Slate 100 */
            color: #1e293b; /* Slate 800 */
            overflow-x: hidden;
        }
        .form-input, .cep-input, .address-search-input {
            transition: all 0.2s ease-in-out;
            border-radius: 0.5rem; border: 1px solid #cbd5e1; /* Slate 300 */
            background-color: #f8fafc; /* Slate 50 */
            color: #1e293b; /* Slate 800 */
            padding: 0.75rem;
        }
        .form-input::placeholder, .cep-input::placeholder, .address-search-input::placeholder { color: #94a3b8; /* Slate 400 */ }
        .form-input:focus, .cep-input:focus, .address-search-input:focus {
             outline: none; border-color: #3b82f6; /* Blue 500 */
             box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); /* Ring Blue 500 */
             background-color: #fff;
        }
        label { color: #475569; /* Slate 600 */}
        .radio-label { color: #334155; /* Slate 700 */}
        input[type="radio"] {
             color: #3b82f6; /* blue-500 */
             border-color: #94a3b8; /* slate-400 */
        }
        input[type="radio"]:focus { ring: #3b82f6; ring-offset-color: #f1f5f9;}
        input[type="radio"]:checked { background-color: #3b82f6; border-color: #3b82f6;}

        /* Estilos dos cards e botões */
        .card {
             background-color: #ffffff; /* White */
             border-radius: 0.75rem;
             box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* Shadow lg */
             border: 1px solid #e2e8f0; /* Slate 200 */
        }
        .btn {
            transition: all 0.2s ease-in-out;
            border-radius: 0.5rem; padding: 0.6rem 1.2rem;
            font-weight: 600; text-align: center; display: inline-flex; /* Para alinhar ícone */
            align-items: center; justify-content: center; gap: 0.5rem; /* Espaço entre texto e ícone */
            cursor: pointer;
        }
         .btn:disabled { /* Estilo para botão desabilitado */
             opacity: 0.5;
             cursor: not-allowed;
         }
        .btn-primary { background-color: #3b82f6; color: white; } /* blue-500 bg */
        .btn-primary:hover:not(:disabled) { background-color: #2563eb; } /* blue-600 */
        .btn-secondary { background-color: #64748b; color: white; } /* slate-500 */
        .btn-secondary:hover:not(:disabled) { background-color: #475569; } /* slate-600 */
         .btn-success { background-color: #10b981; color: white; } /* emerald-500 */
         .btn-success:hover:not(:disabled) { background-color: #059669; } /* emerald-600 */

         .btn-info { background-color: #0ea5e9; color: white; } /* sky-500 */
         .btn-info:hover:not(:disabled) { background-color: #0284c7; } /* sky-600 */

        .btn-danger { background-color: #ef4444; color: white; padding: 0.3rem 0.6rem; font-size: 0.8rem; border: 1px solid #dc2626;} /* red-500 bg */
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; } /* red-600 */
        .btn-lookup { /* Estilo Botão Buscar CEP (ambos) */
             padding: 0.4rem 0.8rem;
             font-size: 0.875rem; /* text-sm */
             background-color: #10b981; /* emerald-500 */
             color: white;
             min-height: calc(1.25rem + 0.8rem + 2px); /* Altura mínima */
             box-sizing: border-box; /* Garante que padding/borda não aumentem o tamanho */
        }
        .btn-lookup:hover:not(:disabled) { background-color: #059669; } /* emerald-600 */

        /* Botão de status */
        .btn-toggle-status {
             padding: 0.3rem 0.6rem; font-size: 0.8rem; min-width: 140px; /* Largura mínima */
             background-color: #f8fafc; /* slate-50 */
             color: #475569; /* slate-600 */
             border: 1px solid #cbd5e1; /* slate-300 */
        }
        .btn-toggle-status:hover:not(:disabled) { background-color: #e2e8f0; }
        /* Verde para Pendente */
        .btn-toggle-status.pending { background-color: #ccfbf1; color: #0f766e; border-color: #5eead4; } /* teal */
        .btn-toggle-status.pending:hover:not(:disabled) { background-color: #99f6e4; }
        /* Cinza para Entregue */
        .btn-toggle-status.delivered { background-color: #e5e7eb; color: #4b5563; border-color: #d1d5db; } /* gray */
        .btn-toggle-status.delivered:hover:not(:disabled) { background-color: #d1d5db; }
        /* Laranja para Não Estava em Casa */
        .btn-toggle-status.not_home { background-color: #ffedd5; color: #9a3412; border-color: #fdba74; } /* orange */
        .btn-toggle-status.not_home:hover:not(:disabled) { background-color: #fed7aa; }


        /* Estilo da Rota Otimizada e Lista de Gerenciamento (compartilhado) */
        .route-list, .management-list { list-style-type: none; margin-left: 0; padding-left: 0; } /* Remove marcadores e padding */
        .route-list { list-style-type: decimal; margin-left: 1.5rem; } /* Adiciona marcador decimal só pra rota */

        .route-list-item, .management-list-item {
             background-color: #ffffff;
             padding: 0.75rem 1rem;
             border-radius: 0.75rem;
             margin-bottom: 1rem;
             border: 1px solid #e2e8f0; /* Slate 200 */
             box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); /* Sombra MD */
             position: relative; /* Para posicionar o status */
        }
         .route-list-item p, .management-list-item p { margin: 0.1rem 0; font-size: 0.95rem; color: #334155; }
         .route-list-item strong, .management-list-item strong {
             color: #1e293b;
             font-size: 1.05rem; /* Aumentado */
         }

        /* Estilos para itens com status */
        .delivered-item {
             opacity: 0.6;
             background-color: #f8fafc; /* slate-50 */
        }
        .delivered-item strong {
             text-decoration: line-through;
             color: #475569; /* slate-600 */
        }
        .not-home-item {
             background-color: #fffbeb; /* yellow-50 */
             border-left: 4px solid #f59e0b; /* amber-500 */
        }

        /* Cor da distância (km) */
        .route-distance {
             font-size: 0.8rem;
             color: #64748b; /* slate-500 */
             font-weight: 500;
             display: block; /* Para ficar abaixo do endereço */
        }

        /* Estilo da lista de entregas (Fallback - Básico) */
        .bairro-group h3 {
             color: #1e3a8a; /* Blue 800 */
             border-bottom: 2px solid #dbeafe; /* Blue 100 */
             margin-top: 1.5rem; margin-bottom: 1rem;
             padding-bottom: 0.5rem; font-size: 1.25rem; font-weight: 600;
        }
        .street-group h4 {
              font-weight: 500; color: #374151; /* gray-700 */
              margin-top: 0.75rem; margin-bottom: 0.5rem;
              padding-left: 0.5rem; font-size: 1rem;
              border-left: 3px solid #60a5fa; /* blue-400 */
        }
        /* Delivery Item Básico usa os estilos de .management-list-item */
        .delivery-item {
             /* Herda de .management-list-item */
             display: flex; /* Adiciona flex para alinhar botões */
             justify-content: space-between;
             align-items: center;
        }

        .size-tag {
             padding: 0.1rem 0.5rem; border-radius: 0.25rem;
             font-size: 0.75rem; font-weight: 500; margin-left: 0.5rem;
        }
        .size-grande { background-color: #fecaca; color: #991b1b; } /* red-200 bg, red-800 text */
        .size-pequeno { background-color: #d1fae5; color: #065f46; } /* green-100 bg, green-800 text */

        /* Estilos para Resultados da Busca de CEP */
        #cep-results {
             margin-top: 1rem; padding: 0.75rem;
             background-color: #f8fafc; /* slate-50 */
             border: 1px solid #e2e8f0; /* slate-200 */
             border-radius: 0.5rem;
             min-height: 50px; max-height: 200px;
             overflow-y: auto;
        }
        #cep-results p {
             margin-bottom: 0.5rem; padding-bottom: 0.5rem;
             border-bottom: 1px dashed #cbd5e1; /* slate-300 */
             font-size: 0.875rem; /* text-sm */
        }
        #cep-results p:last-child { border-bottom: none; margin-bottom: 0; }
         #cep-results strong { color: #1e3a8a; /* blue-800 */ }

        /* Estilo da tela de Carregando/Login */
        #login-container {
             min-height: 100vh;
             display: flex; /* Mostrar por padrão */
             align-items: center;
             justify-content: center;
             background-color: #f1f5f9; /* Slate 100 */
        }
        /* Botão Login Google */
        #google-login-button {
             background-color: #4285F4; /* Google Blue */
             color: white;
             padding: 0.75rem 1.5rem;
             border-radius: 0.5rem;
             font-weight: 600;
             display: inline-flex;
             align-items: center;
             gap: 0.75rem;
             transition: background-color 0.2s;
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #google-login-button:hover { background-color: #357ae8; }
        #google-login-button svg { width: 1.25rem; height: 1.25rem; }


        /* Botões de Navegação */
        .nav-button {
             background-color: transparent; border: none;
             color: #dbeafe; /* blue-200 */
             font-weight: 500; padding: 0.5rem 1rem;
             border-radius: 0.375rem; /* rounded-md */
             transition: all 0.2s;
        }
        .nav-button:hover { background-color: rgba(255, 255, 255, 0.1); color: white; }
        .nav-button.active { background-color: #ffffff; color: #2563eb; } /* bg-white, text-blue-600 */

        /* Barra de Verificação de Email - REMOVIDA PARA SIMPLICIDADE */


        /* Override Print Styles */
        @media print { /* ... estilos de impressão iguais ... */ }
    </style>
</head>
<body class="antialiased">

    <!-- Tela de Login / Carregando -->
    <div id="login-container"> <!-- Mostrar por padrão -->
        <div class="card p-8 text-center max-w-sm mx-auto">
             <div class="flex justify-center items-center gap-4 mb-4">
                 <svg id="loading-spinner" class="h-10 w-10 text-blue-500 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"> /* ... */ </svg>
                 <svg id="static-icon" class="h-10 w-10 text-blue-500" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"> /* ... */ </svg>
                 <h1 class="text-3xl font-title text-slate-800">Organizador de Entregas</h1>
             </div>
             <p id="login-message" class="text-slate-600 mb-6">Verificando autenticação...</p>
             <button id="google-login-button" onclick="loginWithGoogle()" style="display: none;">
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="24px" height="24px"> /* ... */ </svg>
                 Entrar com Google
             </button>
              <p id="auth-error" class="text-red-500 text-sm mt-4" style="display: none;"></p>
        </div>
    </div>

    <!-- Contêiner principal do aplicativo (começa escondido) -->
    <div id="app-container" style="display: none;">
        <header class="bg-gradient-to-r from-blue-600 to-blue-500 shadow-lg pb-4 pt-12 border-b border-blue-700 relative">
            <div class="container mx-auto px-6 text-center">
                 <div class="flex justify-center items-center gap-4 mb-4">
                     <svg class="h-10 w-10 text-white drop-shadow-lg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"> /* ... */ </svg>
                     <h1 class="text-3xl md:text-4xl font-title text-white drop-shadow-md">Organizador de Entregas</h1>
                 </div>
                 <div id="nav-buttons" class="mt-6 flex justify-center gap-2">
                     <button id="nav-route" onclick="showView('route-view')" class="nav-button active">Ver Rota Atual</button>
                     <button id="nav-management" onclick="showView('management-view')" class="nav-button">Gerenciar Entregas</button>
                 </div>
            </div>
            <div id="user-info" class="absolute top-4 right-6 text-white text-right">
                 <p id="user-display-name" class="text-sm font-medium truncate max-w-[200px]" title="Usuário logado"></p>
                 <button onclick="logout()" class="text-xs font-semibold text-blue-200 hover:text-white hover:underline transition-colors">
                     Sair
                 </button>
            </div>
        </header>

        <!-- Barra de Verificação de Email Removida -->

        <main class="container mx-auto px-6 py-8">
            <div class="max-w-2xl mx-auto">
                <div id="route-view">
                    <section id="start-address-section" class="card p-6 mb-8"> /* ... Campos Base ... */ </section>
                    <section id="add-delivery-form" class="card p-6 mb-8"> /* ... Campos Nova Entrega ... */ </section>
                    <section id="cep-search-form" class="card p-6 mb-8"> /* ... Busca CEP por Endereço ... */ </section>
                    <section id="delivery-list-section" class="card p-6"> /* ... Lista Rota ... */ </section>
                </div>
                <div id="management-view" style="display: none;">
                     <section class="card p-6"> /* ... Lista Gerenciamento ... */ </section>
                 </div>
            </div>
        </main>
    </div> <!-- Fim do #app-container -->


    <!-- Firebase -->
    <script type="module">
        // Importações
        import { initializeApp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getAuth,
            onAuthStateChanged,
            signInWithRedirect,
            getRedirectResult, // <-- Adicionado
            GoogleAuthProvider,
            signOut
            // Removido sendEmailVerification
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore, collection, addDoc, onSnapshot, query, deleteDoc,
            doc, Timestamp, setDoc, getDoc, updateDoc, orderBy
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Variáveis Globais
        let app;
        let db;
        let auth;
        let userId;
        let deliveriesUnsubscribe = null;
        let currentDeliveries = [];
        let startingAddress = '';
        let lastOptimizedRoute = [];
        let currentView = 'route-view';
        let authReady = false; // Flag original da versão fornecida pelo usuário

        // Elementos DOM
        const loginContainer = document.getElementById('login-container');
        const appContainer = document.getElementById('app-container');
        const userDisplayElement = document.getElementById('user-display-name');
        const authErrorElement = document.getElementById('auth-error');
        const loginMessageElement = document.getElementById('login-message'); // Para status
        const loginButton = document.getElementById('google-login-button');
        const loadingSpinner = document.getElementById('loading-spinner');
        const staticIcon = document.getElementById('static-icon');
        // Removidos elementos da barra de verificação


        // Configuração Firebase (Sua Configuração)
        const firebaseConfig = {
         apiKey: "AIzaSyCmskiIAKHmyfw1FapQzQsK1I7GzXgdVcc",
         authDomain: "otimizadorderotas-4ecad.firebaseapp.com",
         projectId: "otimizadorderotas-4ecad",
         storageBucket: "otimizadorderotas-4ecad.appspot.com",
         messagingSenderId: "19873425863",
         appId: "1:19873425863:web:817b4ff574200bbf7751e2",
         measurementId: "G-9Z7YT0DYCE"
        };

        let firebaseInitialized = false;

        // Função para atualizar UI de login/loading (original)
        function updateLoginUI(isLoading, message, isError = false) {
             console.log(`[UI Update] isLoading=${isLoading}, message=${message}, isError=${isError}`);
             if (loginMessageElement) loginMessageElement.textContent = message;
             if (authErrorElement) {
                 authErrorElement.textContent = isError ? message : '';
                 authErrorElement.style.display = isError ? 'block' : 'none';
                 if(isError && loginMessageElement) loginMessageElement.style.display = 'none';
                 else if (loginMessageElement) loginMessageElement.style.display = 'block';
             }
             if (loginButton) loginButton.style.display = (!isLoading && !isError) ? 'inline-flex' : 'none';
             if (loadingSpinner) loadingSpinner.style.display = isLoading ? 'block' : 'none';
             if (staticIcon) staticIcon.style.display = isLoading ? 'none' : 'block';
        }

        // --- Inicialização e Autenticação (Original do usuário com correções mínimas) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Carregado. Inicializando Firebase...");
            updateLoginUI(true, "Inicializando..."); // Mantém carregando
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                firebaseInitialized = true;
                console.log("Firebase inicializado OK.");
                // setLogLevel('debug');

                console.log("Verificando resultado do Redirect...");
                updateLoginUI(true, "Verificando autenticação..."); // Mantém carregando

                getRedirectResult(auth)
                    .then(async (result) => {
                        authReady = true; // <-- Marca como pronto APÓS getRedirectResult
                        console.log("getRedirectResult concluído.");
                        if (result && result.user) {
                            console.log("Redirect Result OBTEVE usuário:", result.user.uid);
                            // O onAuthStateChanged (configurado abaixo) vai pegar esse usuário
                        } else {
                            console.log("Nenhum usuário obtido do Redirect Result.");
                            // Se não veio do redirect e o estado atual não tem user, mostra login
                            if(!auth.currentUser){ // Verifica se JÁ existe usuário na sessão atual
                                console.log("Nenhum usuário na sessão atual, mostrando login.");
                                updateLoginUI(false, "Faça login para salvar e gerenciar suas rotas.");
                            }
                        }
                        // Configura o listener DEPOIS de verificar o redirect
                        setupAuthStateListener();
                    })
                    .catch((error) => {
                        authReady = true; // <-- Marca como pronto mesmo com erro
                        console.error("Erro ao verificar Redirect Result:", error.code, error.message);
                        updateLoginUI(false, `Erro na verificação inicial: ${error.message}`, true);
                        // Configura o listener mesmo com erro, para pegar estado logado anterior
                        setupAuthStateListener();
                    });

                // Função que configura o listener principal
                function setupAuthStateListener() {
                    console.log("Configurando onAuthStateChanged listener...");
                    onAuthStateChanged(auth, async (user) => {
                        console.log("onAuthStateChanged disparado. Usuário:", user ? user.uid : 'null', "AuthReady:", authReady);

                        // Só age se a verificação inicial (getRedirectResult) já terminou
                        if (!authReady) {
                            console.log("Auth ainda não está pronta, aguardando...");
                            return; // Sai e espera a próxima chamada
                        }

                        if (user) {
                            // Usuário LOGADO
                            userId = user.uid;
                            console.log("Estado: LOGADO.", user.displayName, userId);
                            if (userDisplayElement) {
                                userDisplayElement.textContent = user.displayName || user.email || `Usuário ${userId.substring(0,6)}...`;
                                userDisplayElement.title = user.email || `ID: ${userId}`;
                            }

                            if (appContainer) appContainer.style.display = 'block';
                            if (loginContainer) loginContainer.style.display = 'none';
                            showView(currentView);
                            await loadSettings();
                            loadDeliveries();
                        } else {
                            // Usuário DESLOGADO
                            console.log("Estado: DESLOGADO.");
                            userId = null; startingAddress = ''; // Limpa variáveis
                            if (appContainer) appContainer.style.display = 'none';
                            if (loginContainer) loginContainer.style.display = 'flex'; // MOSTRA tela de login
                            if (firebaseInitialized) {
                                updateLoginUI(false, "Faça login para salvar e gerenciar suas rotas.");
                            } else {
                                updateLoginUI(false, "Erro na inicialização. Recarregue.", true);
                            }
                            if (deliveriesUnsubscribe) { deliveriesUnsubscribe(); deliveriesUnsubscribe = null; }
                            currentDeliveries = []; lastOptimizedRoute = [];
                             // Limpa campos base e entrega
                            const startAddressInput = document.getElementById('start-address');
                            if (startAddressInput) startAddressInput.value = '';
                            ['cep', 'address', 'neighborhood'].forEach(id => {
                                const el = document.getElementById(id); if (el) el.value = '';
                            });
                             const sizePequenoRadio = document.querySelector('input[name="size"][value="Pequeno"]');
                             if (sizePequenoRadio) sizePequenoRadio.checked = true;
                        }
                    });
                }
                // --- FIM: Lógica de Autenticação ---

            } catch (initError) {
                 console.error("Erro CRÍTICO ao inicializar Firebase:", initError);
                 updateLoginUI(false, `Erro Crítico: ${initError.message}. Verifique a config.`, true);
                 if (appContainer) appContainer.style.display = 'none';
                 if (loginContainer) loginContainer.style.display = 'flex';
                 firebaseInitialized = false;
                 authReady = true; // Permite mostrar erro
            }
        }); // Fim do DOMContentLoaded


        // Função de Login com Google (usa Redirect - Original do usuário)
        window.loginWithGoogle = async () => {
             if (!auth || !firebaseInitialized) return;
             const provider = new GoogleAuthProvider();
             updateLoginUI(true, "Redirecionando para o Google...");
             if (authErrorElement) authErrorElement.style.display = 'none';
             try {
                 await signInWithRedirect(auth, provider);
             } catch (error) {
                 console.error("Erro ao iniciar signInWithRedirect:", error);
                 updateLoginUI(false, `Erro: ${error.code} - ${error.message}`, true);
             }
        };

        // Logout (Original do usuário com logs)
        window.logout = async () => {
            console.log("Logout function called.");
            if (!auth || !firebaseInitialized) {
                 console.warn("Logout attempt aborted: Auth or Firebase not ready.");
                 return;
            }
            try {
                console.log("Attempting signOut...");
                await signOut(auth);
                console.log("signOut successful. onAuthStateChanged should trigger.");
            } catch (error) {
                 console.error("Erro CRÍTICO ao sair:", error);
                 if (authErrorElement) {
                     authErrorElement.textContent = `Erro ao sair: ${error.message}`;
                     authErrorElement.style.display = 'block';
                 }
            }
        };


        // --- Controle de Visualização ---
        window.showView = (viewId) => {
             console.log("Mudando para view:", viewId);
             currentView = viewId;
             const routeV = document.getElementById('route-view');
             const mgmtV = document.getElementById('management-view');
             if (routeV) routeV.style.display = 'none';
             if (mgmtV) mgmtV.style.display = 'none';

             const targetView = document.getElementById(viewId);
             if (targetView) targetView.style.display = 'block';

             // Atualiza botões
             const navRoute = document.getElementById('nav-route');
             const navMgmt = document.getElementById('nav-management');
             if (navRoute) navRoute.classList.toggle('active', viewId === 'route-view');
             if (navMgmt) navMgmt.classList.toggle('active', viewId === 'management-view');

             // Renderiza lista apropriada
             if (viewId === 'management-view') {
                 renderManagementList(currentDeliveries);
             } else if (firebaseInitialized && authReady && userId) { // Só re-renderiza se logado
                 optimizeAndRenderRoutes(currentDeliveries, true); // Otimiza silenciosamente ao mudar para a view
             }
        };

        // --- Funções Firebase (com verificações) ---
        function getFirestoreCollection(collectionName) {
            if (!userId || !db) {
                console.warn(`Firestore não disponível ou usuário não logado para acessar coleção: ${collectionName}`);
                return null;
            }
            return collection(db, `users/${userId}/${collectionName}`);
        }
        function getFirestoreDoc(collectionName, docId) {
            const collRef = getFirestoreCollection(collectionName);
            if (!collRef || !docId) return null;
            return doc(collRef, docId);
        }
        function getSettingsDocRef() {
            if (!userId || !db) return null;
            return doc(db, `users/${userId}/config/appSettings`);
        }
        async function saveSettings(settingsData) {
            const docRef = getSettingsDocRef();
            if (!docRef) { console.warn("Não foi possível salvar config: Ref nula."); return; }
            try {
                await setDoc(docRef, settingsData, { merge: true });
                console.log("Settings saved:", settingsData);
                if (settingsData.startingAddress !== undefined) startingAddress = settingsData.startingAddress;
            } catch (error) { console.error("Error saving settings:", error); }
        }
        async function loadSettings() {
            const docRef = getSettingsDocRef();
            if (!docRef) { console.warn("Não foi possível carregar config: Ref nula."); return; }
            try {
                const docSnap = await getDoc(docRef);
                const addressInput = document.getElementById('start-address');
                if (docSnap.exists()) {
                    const settings = docSnap.data();
                    startingAddress = settings.startingAddress || '';
                    if (addressInput) addressInput.value = startingAddress;
                } else {
                    startingAddress = '';
                    if (addressInput) addressInput.value = '';
                }
            } catch (error) {
                console.error("Error loading settings:", error);
                startingAddress = '';
                const addressInput = document.getElementById('start-address');
                if (addressInput) addressInput.value = '';
            }
        }

        // Adiciona entrega (com correção de verificação)
        window.addDelivery = function() {
              const collRef = getFirestoreCollection('deliveries');
              const cepErrorEl = document.getElementById('cep-error'); // ID correto

              // Verificação reforçada
              if (!firebaseInitialized || !auth.currentUser || !userId || !db) { // Usa currentUser
                   console.warn("Tentativa de adicionar entrega antes da autenticação/DB estar pronto.");
                   if(cepErrorEl){
                       cepErrorEl.textContent="Aguardando conexão/autenticação... Tente novamente em alguns segundos.";
                       cepErrorEl.style.display='block';
                   }
                   return;
               }

              if (!collRef) {
                  console.error("Falha ao obter referência da coleção 'deliveries'.");
                   if(cepErrorEl){
                       cepErrorEl.textContent="Erro DB: Não foi possível acessar o banco de dados.";
                       cepErrorEl.style.display='block';
                   }
                  return;
              }

              // Pega valores dos campos originais
              const addressInput = document.getElementById('address');
              const neighborhoodInput = document.getElementById('neighborhood');
              const sizeInput = document.querySelector('input[name="size"]:checked');
              const cepInput = document.getElementById('cep');

              const address = addressInput.value.trim();
              const neighborhood = neighborhoodInput.value.trim();
              const size = sizeInput ? sizeInput.value : 'Pequeno';
              const cep = cepInput.value.replace(/\D/g, '');

              // Validação
              if (!address || !neighborhood) {
                  if(cepErrorEl){ cepErrorEl.textContent="Endereço Completo e Bairro são obrigatórios."; cepErrorEl.style.display='block';}
                  return;
              }
               if(cepErrorEl) cepErrorEl.style.display='none';

              const newDelivery = {
                  address: address,
                  neighborhood: neighborhood,
                  size,
                  cep: cep || null,
                  createdAt: Timestamp.now(),
                  status: 'pending'
              };

              console.log("Tentando adicionar documento:", newDelivery);
              addDoc(collRef, newDelivery)
                   .then((docRef) => {
                       console.log("Documento adicionado com ID:", docRef.id);
                       addressInput.value = '';
                       neighborhoodInput.value = '';
                       cepInput.value = '';
                       document.querySelector('input[name="size"][value="Pequeno"]').checked = true;
                   })
                   .catch(error => {
                       console.error("Firestore addDoc Error:", error.code, error.message, error);
                       if (cepErrorEl) {
                           cepErrorEl.textContent = `Erro DB ao salvar: ${error.message} (Código: ${error.code})`;
                           cepErrorEl.style.display = 'block';
                       }
                   });
        }
        function loadDeliveries() {
            const collRef = getFirestoreCollection('deliveries');
            if (!collRef) { renderRouteList([], true, {}); renderManagementList([]); return; }
            if (deliveriesUnsubscribe) deliveriesUnsubscribe();
            const q = query(collRef, orderBy("createdAt", "desc"));
            deliveriesUnsubscribe = onSnapshot(q, (querySnapshot) => {
                currentDeliveries = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                if (currentView === 'management-view') {
                    renderManagementList(currentDeliveries);
                } else {
                    optimizeAndRenderRoutes(currentDeliveries, true); // Otimiza na carga inicial ou mudança
                }
            }, (error) => {
                 console.error("Erro ao carregar entregas (onSnapshot):", error);
                 renderRouteList([], true, {}); renderManagementList([]); // Limpa UI em caso de erro
            });
        }
        window.toggleDeliveryStatus = async (deliveryId, currentStatus) => {
            const docRef = getFirestoreDoc('deliveries', deliveryId);
            if (!docRef) return;
             let newStatus;
             if (currentStatus === 'pending') newStatus = 'delivered';
             else if (currentStatus === 'delivered') newStatus = 'not_home';
             else newStatus = 'pending';
             try { await updateDoc(docRef, { status: newStatus }); }
             catch (error) { console.error("Erro toggleStatus:", error); }
        };
        window.deleteDelivery = function(deliveryId) { // Chamado por handleConfirmDelete
            const docRef = getFirestoreDoc('deliveries', deliveryId);
            if (!docRef) return;
            deleteDoc(docRef)
                .then(() => console.log("Excluído:", deliveryId))
                .catch(error => { console.error("Erro ao excluir:", error); });
        };

        // --- Otimização e Rota ---
        window.runOptimization = async function(isInitialLoad = false) {
             const routeStatus = document.getElementById('route-status');
             const optimizeButton = document.getElementById('update-route-button');
             const startAddressInput = document.getElementById('start-address');
             const currentAddressValue = startAddressInput ? startAddressInput.value.trim() : '';

             // Salva se mudou
             if (currentAddressValue && currentAddressValue !== startingAddress) {
                 startingAddress = currentAddressValue;
                 await saveSettings({ startingAddress: startingAddress });
             } else if (!startingAddress && currentAddressValue) {
                  startingAddress = currentAddressValue;
                  await saveSettings({ startingAddress: startingAddress });
             }

             if (!isInitialLoad) {
                 console.log("Iniciando otimização manual...");
                 if (routeStatus) { routeStatus.textContent = "Otimizando rota..."; routeStatus.style.display = 'block'; }
                 if (optimizeButton) optimizeButton.disabled = true;
             }

             await optimizeAndRenderRoutes(currentDeliveries, isInitialLoad, startingAddress); // Passa a string

             if (!isInitialLoad && optimizeButton) {
                 optimizeButton.disabled = false;
             }
        }
        // optimizeAndRenderRoutes (Usa API V1 - como no código original)
        async function optimizeAndRenderRoutes(allDeliveries, isInitialLoad = false, startAddrString = null) {
            const routeStatus = document.getElementById('route-status');
            const startAddr = startAddrString !== null ? startAddrString : startingAddress; // Usa a string
            const deliveriesToOptimize = allDeliveries.filter(d => d.status === 'pending' || d.status === 'not_home');
            const failedDeliveries = {};

            console.log(`optimizeAndRenderRoutes chamado. isInitialLoad: ${isInitialLoad}, startAddr: ${startAddr}, deliveriesToOptimize: ${deliveriesToOptimize.length}`);

            if (!startAddr && deliveriesToOptimize.length > 0) {
                 console.warn("Endereço de partida não definido. Usando ordenação básica.");
                 if (routeStatus && !isInitialLoad) routeStatus.textContent = "Ordenação básica (Defina um endereço de partida).";
                 const basicSorted = basicSortDeliveries(allDeliveries);
                 lastOptimizedRoute = basicSorted; // Salva a rota (mesmo básica)
                 if (currentView === 'route-view') { // Só renderiza se na view correta
                      renderRouteList(basicSorted, true, {});
                 }
                 return;
            }
            if (deliveriesToOptimize.length === 0) {
                 console.log("Nenhuma entrega pendente/não em casa para otimizar.");
                 lastOptimizedRoute = []; // Limpa a rota otimizada
                 if (currentView === 'route-view') { // Só renderiza se na view correta
                      renderRouteList([], true, {}); // Mostra lista vazia na aba Rota
                 }
                 if (routeStatus) routeStatus.style.display = 'none';
                 return;
            }


            if (!isInitialLoad && routeStatus) {
                 routeStatus.textContent = "Buscando coordenadas...";
                 routeStatus.style.display = 'block';
            }

            try {
                // Chave V1 (como no código original)
                const apiKey = "5b3ce3597851110001cf624852da619a1e2f42b7984cc26314de2636";

                const locations = [startAddr, ...deliveriesToOptimize.map(d => d.address)];
                const coordinates = [];
                const geoCache = new Map(); // Simples cache em memória

                for (let i = 0; i < locations.length; i++) {
                    const address = locations[i];
                    const isStart = i === 0;
                    const delivery = isStart ? null : deliveriesToOptimize[i - 1];
                    const cacheKey = address + (delivery ? delivery.id : 'start');

                    if (geoCache.has(cacheKey)) { coordinates.push(geoCache.get(cacheKey)); continue; }
                    if (!isInitialLoad && routeStatus) routeStatus.textContent = `Buscando coord. (${i + 1}/${locations.length})...`;
                    await new Promise(resolve => setTimeout(resolve, 1500)); // Delay API

                    try {
                        // Endpoint V1 (como no código original)
                        const geoResponse = await fetch(`https://api.openrouteservice.org/geocode/search?api_key=${apiKey}&text=${encodeURIComponent(address)}`);
                        if (!geoResponse.ok) throw new Error(`Status ${geoResponse.status}`);
                        const geoData = await geoResponse.json();
                        if (!geoData.features || geoData.features.length === 0) throw new Error(`Não encontrado`);
                        const coord = geoData.features[0].geometry.coordinates; // [lon, lat]
                        geoCache.set(cacheKey, coord); coordinates.push(coord);
                    } catch (geoError) {
                        console.error(`Falha ao geocodificar "${address}":`, geoError.message);
                        if (isStart) throw new Error(`Falha ao encontrar coordenadas do endereço de partida "${startAddr}". Verifique o endereço.`);
                        else if (delivery) failedDeliveries[delivery.id] = {...delivery, error: geoError.message};
                        coordinates.push(null);
                    }
                }
                console.log("Coordenadas obtidas:", coordinates);

                 // Verifica se a coordenada de partida (índice 0) é válida
                 if (!coordinates[0]) {
                     throw new Error(`Falha ao encontrar coordenadas do endereço de partida "${startAddr}". Verifique o endereço.`);
                 }


                const validDeliveriesWithCoords = deliveriesToOptimize
                    .map((delivery, index) => ({
                         ...delivery,
                         coords: coordinates[index + 1] ? { latitude: coordinates[index + 1][1], longitude: coordinates[index + 1][0] } : null
                     }))
                    .filter(d => d.coords !== null);

                 if (validDeliveriesWithCoords.length === 0) {
                     // Se não tem válidas, mas tem falhas
                     if (Object.keys(failedDeliveries).length > 0) {
                        console.warn("Nenhuma entrega válida encontrada, mostrando falhas.");
                        lastOptimizedRoute = []; // Nenhuma rota otimizada
                         if (currentView === 'route-view') {
                            renderRouteList([], true, failedDeliveries); // Usa modo básico para mostrar falhas
                        }
                        if (routeStatus && !isInitialLoad) routeStatus.textContent = "Nenhuma entrega pôde ser localizada.";
                     } else { // Se não tem nem válidas nem falhas (lista inicial vazia)
                        console.log("Nenhuma entrega válida ou com falha para processar.");
                        lastOptimizedRoute = [];
                         if (currentView === 'route-view') {
                            renderRouteList([], true, {});
                        }
                        if (routeStatus) routeStatus.style.display = 'none';
                     }
                    return; // Interrompe aqui se não há entregas válidas
                 }


                // Otimização (Vizinho Mais Próximo)
                if (!isInitialLoad && routeStatus) routeStatus.textContent = `Calculando rota para ${validDeliveriesWithCoords.length} entregas...`;
                let currentCoords = { latitude: coordinates[0][1], longitude: coordinates[0][0] }; // Usa a coordenada de partida validada
                let remainingValidDeliveries = [...validDeliveriesWithCoords];
                let optimizedRoute = [];

                while (remainingValidDeliveries.length > 0) {
                    let closestDistance = Infinity;
                    let closestIndex = -1;
                    remainingValidDeliveries.forEach((delivery, index) => {
                        const distance = getHaversineDistance(currentCoords, delivery.coords);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestIndex = index;
                        }
                    });
                    const closestDelivery = remainingValidDeliveries.splice(closestIndex, 1)[0];
                    closestDelivery.distanceFromPrevious = closestDistance;
                    optimizedRoute.push(closestDelivery);
                    currentCoords = closestDelivery.coords;
                }

                console.log("Rota otimizada:", optimizedRoute);
                lastOptimizedRoute = optimizedRoute;

                if (routeStatus && !isInitialLoad) {
                     let statusMsg = `Rota otimizada para ${optimizedRoute.length} entregas!`;
                     if (Object.keys(failedDeliveries).length > 0) {
                         statusMsg += ` (${Object.keys(failedDeliveries).length} não localizadas).`;
                     }
                     routeStatus.textContent = statusMsg;
                 } else if (routeStatus) {
                     routeStatus.style.display = 'none';
                 }


                if (currentView === 'route-view') {
                    renderRouteList(optimizedRoute, false, failedDeliveries);
                }

            } catch (error) {
                console.error("Erro durante otimização/geocodificação:", error);
                if (routeStatus && !isInitialLoad) routeStatus.textContent = `Erro: ${error.message}. Usando ordenação básica.`;
                const basicSorted = basicSortDeliveries(allDeliveries);
                lastOptimizedRoute = basicSorted;
                if (currentView === 'route-view') {
                    renderRouteList(basicSorted, true, failedDeliveries); // Mostra falhas mesmo no fallback
                }
            }
        }


        // --- Busca CEP ---
        // Busca CEP para Nova Entrega (Corrigida)
        window.fetchAddressByCEP = async function() {
            const cepInput = document.getElementById('cep'); // <<< ID CORRETO
            const cep = cepInput ? cepInput.value.replace(/\D/g, '') : '';
            const addressInput = document.getElementById('address');
            const neighborhoodInput = document.getElementById('neighborhood');
            const errorElement = document.getElementById('cep-error'); // <<< ID CORRETO
            const lookupButton = document.getElementById('cep-lookup-button'); // <<< ID CORRETO

            if (!cepInput || !addressInput || !neighborhoodInput || !errorElement || !lookupButton) {
                 console.error("Elementos CEP entrega não encontrados."); return;
            }
            if (cep.length !== 8) { errorElement.textContent = "CEP inválido. Deve conter 8 dígitos."; errorElement.style.display = 'block'; return; }
            if(errorElement) errorElement.style.display = 'none';

            lookupButton.disabled = true; lookupButton.innerHTML = `<svg class="animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Buscando...`;

            try {
                const response = await fetch(`https://viacep.com.br/ws/${cep}/json/`);
                if (!response.ok) throw new Error(`Erro API ViaCEP: ${response.status}`);
                const data = await response.json();
                console.log("ViaCEP (Entrega) response:", data);

                if (data.erro) { errorElement.textContent = "CEP não encontrado."; errorElement.style.display = 'block'; }
                else {
                    let fullAddress = `${data.logradouro || ''}`;
                    if(data.logradouro) fullAddress += `, [NÚMERO]`;
                    // Não adiciona bairro aqui, ele vai no campo separado
                    if(data.localidade) fullAddress += `${fullAddress ? ', ' : ''}${data.localidade}`;
                    if(data.uf) fullAddress += `${fullAddress ? ' - ' : ''}${data.uf}`;
                    addressInput.value = fullAddress.replace(/^,\s*\[NÚMERO\]/, '[NÚMERO]').trim();
                    neighborhoodInput.value = data.bairro || '';
                    addressInput.focus();
                    const placeholderIndex = addressInput.value.indexOf('[NÚMERO]');
                    if (placeholderIndex !== -1) {
                         setTimeout(() => { addressInput.setSelectionRange(placeholderIndex, placeholderIndex + '[NÚMERO]'.length); }, 0);
                    }
                }
            } catch (error) {
                 console.error("Erro fetchAddressByCEP:", error);
                 errorElement.textContent = `Erro: ${error.message}. Verifique a conexão.`; errorElement.style.display = 'block';
             }
            finally {
                 lookupButton.disabled = false;
                 lookupButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4"><path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 1 0 0 11 5.5 5.5 0 0 0 0-11ZM2 9a7 7 0 1 1 12.452 4.391l3.328 3.329a.75.75 0 1 1-1.06 1.06l-3.329-3.328A7 7 0 0 1 2 9Z" clip-rule="evenodd" /></svg> Buscar`;
            }
        }

        // Busca CEP para Endereço Base (Corrigida)
        window.fetchBaseAddressByCEP = async function() {
            const cepInput = document.getElementById('start-cep'); // <<< ID CORRETO
            const cep = cepInput ? cepInput.value.replace(/\D/g, '') : '';
            const addressInput = document.getElementById('start-address'); // Campo único base
            const errorElement = document.getElementById('start-cep-error'); // <<< ID CORRETO
            const lookupButton = document.getElementById('start-cep-lookup-button'); // <<< ID CORRETO

            let newAddressToSave = null;

            if (!cepInput || !addressInput || !errorElement || !lookupButton) {
                 console.error("Elementos CEP base não encontrados."); return;
            }
            if (cep.length !== 8) { errorElement.textContent = "CEP inválido. Deve conter 8 dígitos."; errorElement.style.display = 'block'; return; }
            if(errorElement) errorElement.style.display = 'none';

            lookupButton.disabled = true; lookupButton.innerHTML = `<svg class="animate-spin h-4 w-4 text-white" ...></svg> Buscando...`;

            try {
                const response = await fetch(`https://viacep.com.br/ws/${cep}/json/`);
                if (!response.ok) throw new Error(`Erro API ViaCEP: ${response.status}`);
                const data = await response.json();
                console.log("ViaCEP (Base) response:", data);

                if (data.erro) { errorElement.textContent = "CEP não encontrado."; errorElement.style.display = 'block'; }
                else {
                    let fullAddress = `${data.logradouro || ''}`;
                    if (data.logradouro) fullAddress += `, [NÚMERO]`; // Placeholder número
                    if(data.bairro) fullAddress += `${fullAddress ? ', ' : ''}${data.bairro}`;
                    if(data.localidade) fullAddress += `${fullAddress ? ', ' : ''}${data.localidade}`;
                    if(data.uf) fullAddress += `${fullAddress ? ' - ' : ''}${data.uf}`;

                    addressInput.value = fullAddress.replace(/^,\s*\[NÚMERO\]/, '[NÚMERO]').replace(/,\s*,/g, ',').trim();
                    newAddressToSave = addressInput.value;
                    addressInput.focus();
                    const placeholderIndex = addressInput.value.indexOf('[NÚMERO]');
                    if (placeholderIndex !== -1) {
                         setTimeout(() => { addressInput.setSelectionRange(placeholderIndex, placeholderIndex + '[NÚMERO]'.length); }, 0);
                    }
                }
            } catch (error) {
                console.error("Erro fetchBaseAddressByCEP:", error);
                errorElement.textContent = `Erro: ${error.message}. Verifique a conexão.`; errorElement.style.display = 'block';
            }
            finally {
                 lookupButton.disabled = false;
                 lookupButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4"><path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 1 0 0 11 5.5 5.5 0 0 0 0-11ZM2 9a7 7 0 1 1 12.452 4.391l3.328 3.329a.75.75 0 1 1-1.06 1.06l-3.329-3.328A7 7 0 0 1 2 9Z" clip-rule="evenodd" /></svg> Buscar`;
            }

            if (newAddressToSave) {
                await saveSettings({ startingAddress: newAddressToSave });
            }
        }


        // Busca CEPs por Endereço (igual, com logs)
        window.searchCEPsByAddress = async function() { /* ... código igual (com logs) ... */ }


        // --- Funções de Helper e Renderização ---
        function getHaversineDistance(coords1, coords2) { /* ... */ }
        function basicSortDeliveries(deliveries) { /* ... */ }
        function renderRouteList(deliveries, isBasicSort, failedDeliveries) { /* ... */ }
        function renderManagementList(allDeliveries) { /* ... */ }
        function renderOptimizedList(listElement, deliveries) { /* ... */ }
        function renderBasicGroup(listElement, groupedDeliveries, context) { /* ... */ }
        function renderFailedList(listElement, failedDeliveries) { /* ... */ }
        function renderGenericDeliveryItem(parentElement, delivery, context, streetNameIfBasic = null) { /* ... */ }
        function handleConfirmDelete(buttonElement, deliveryId) { /* ... */ }
        window.openGoogleMaps = function() { /* ... */ }
        window.printList = (context) => { /* ... */ };

    </script>
</body>
</html>

