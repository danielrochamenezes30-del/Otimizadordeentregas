  <!-- ... existing HTML code ... -->

    <!-- Firebase -->
    <script type="module">
        // Importações (iguais)
        import { initializeApp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getAuth,
            onAuthStateChanged,
            signInWithPopup,
            GoogleAuthProvider,
            signOut,
            sendEmailVerification // <-- Importado
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore, collection, addDoc, onSnapshot, query, deleteDoc,
            doc, Timestamp, setDoc, getDoc, updateDoc, orderBy
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Variáveis Globais (iguais)
        let app;
        let db;
        let auth;
        let userId;
        let deliveriesUnsubscribe = null;
        let currentDeliveries = [];
        let startingAddress = '';
        let lastOptimizedRoute = [];
        let currentView = 'route-view';
        let authReady = false; // Flag para indicar se a verificação inicial terminou

        // Elementos DOM (iguais)
        const loginContainer = document.getElementById('login-container');
        const appContainer = document.getElementById('app-container');
        const userDisplayElement = document.getElementById('user-display-name');
        const authErrorElement = document.getElementById('auth-error');
        const loginMessageElement = document.getElementById('login-message');
        const loginButton = document.getElementById('google-login-button');
        const loadingSpinner = document.getElementById('loading-spinner');
        const staticIcon = document.getElementById('static-icon');
        const emailVerificationBar = document.getElementById('email-verification-bar');
        const resendVerificationButton = document.getElementById('resend-verification-button');
        const resendStatusElement = document.getElementById('resend-status');


        // Configuração Firebase (Sua Configuração) (igual)
        const firebaseConfig = {
         apiKey: "AIzaSyCmskiIAKHmyfw1FapQzQsK1I7GzXgdVcc",
         authDomain: "otimizadorderotas-4ecad.firebaseapp.com",
         projectId: "otimizadorderotas-4ecad",
         storageBucket: "otimizadorderotas-4ecad.appspot.com",
         messagingSenderId: "19873425863",
         appId: "1:19873425863:web:817b4ff574200bbf7751e2",
         measurementId: "G-9Z7YT0DYCE"
        };

        let firebaseInitialized = false;

        // Função para atualizar UI de login/loading (igual)
        function updateLoginUI(isLoading, message, isError = false) {
             console.log(`[UI Update] isLoading=${isLoading}, message=${message}, isError=${isError}`);
             if (loginMessageElement) loginMessageElement.textContent = message;
             if (authErrorElement) {
                 authErrorElement.textContent = isError ? message : '';
                 authErrorElement.style.display = isError ? 'block' : 'none';
                 if(isError && loginMessageElement) loginMessageElement.style.display = 'none';
                 else if (loginMessageElement) loginMessageElement.style.display = 'block';
             }
             if (loginButton) loginButton.style.display = (!isLoading && !isError) ? 'inline-flex' : 'none';
             if (loadingSpinner) loadingSpinner.style.display = isLoading ? 'block' : 'none';
             if (staticIcon) staticIcon.style.display = isLoading ? 'none' : 'block';
        }

        // Espera o DOM carregar antes de inicializar Firebase (igual)
        document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM Carregado. Inicializando Firebase...");
             updateLoginUI(true, "Inicializando..."); // Mostra carregando inicial
             try {
                 app = initializeApp(firebaseConfig);
                 db = getFirestore(app);
                 auth = getAuth(app);
                 firebaseInitialized = true;
                 console.log("Firebase inicializado OK.");
                 // setLogLevel('debug');

                 // --- INÍCIO: Lógica de Autenticação com Verificação --- (igual)
                 onAuthStateChanged(auth, async (user) => {
                      console.log("onAuthStateChanged disparado. Usuário:", user ? user.uid : 'null', "Email Verificado:", user ? user.emailVerified : 'N/A');
                      authReady = true;

                      if (user) {
                          // Usuário LOGADO
                          userId = user.uid;
                          console.log("Estado: LOGADO.", user.displayName, userId);
                          if (userDisplayElement) {
                              userDisplayElement.textContent = user.displayName || user.email || `Usuário ${userId.substring(0,6)}...`;
                              userDisplayElement.title = user.email || `ID: ${userId}`;
                          }

                          // Verifica e envia email de verificação se necessário
                          if (!user.emailVerified) {
                              console.log("E-mail não verificado. Tentando enviar verificação...");
                              // Verifica se já enviamos recentemente para evitar spam
                              const lastSent = sessionStorage.getItem('verificationEmailSent');
                              const now = Date.now();
                              if (!lastSent || (now - parseInt(lastSent)) > 60000) { // 1 minuto de cooldown
                                   sendEmailVerification(user)
                                        .then(() => {
                                             sessionStorage.setItem('verificationEmailSent', now.toString());
                                             console.log("E-mail de verificação enviado.");
                                             if (emailVerificationBar) emailVerificationBar.style.display = 'block';
                                             if (resendStatusElement) resendStatusElement.textContent = 'E-mail enviado!';
                                             if (resendVerificationButton) resendVerificationButton.disabled = false;
                                        })
                                        .catch((error) => {
                                             console.error("Erro ao enviar email de verificação:", error);
                                             if (emailVerificationBar) emailVerificationBar.style.display = 'block';
                                             if (resendStatusElement) resendStatusElement.textContent = `Erro ao enviar: ${error.code}`;
                                             if (resendVerificationButton) resendVerificationButton.disabled = false; // Reabilita em caso de erro
                                         });
                              } else {
                                   console.log("Envio de verificação pulado (muito recente).");
                                   if (emailVerificationBar) emailVerificationBar.style.display = 'block';
                                   if (resendStatusElement) resendStatusElement.textContent = 'Verifique seu e-mail.';
                                   if (resendVerificationButton) resendVerificationButton.disabled = false;
                              }
                          } else {
                              console.log("E-mail já verificado.");
                              if (emailVerificationBar) emailVerificationBar.style.display = 'none';
                          }


                          if (appContainer) appContainer.style.display = 'block';
                          if (loginContainer) loginContainer.style.display = 'none';
                          showView(currentView);
                          await loadSettings();
                          loadDeliveries();
                      } else {
                          // Usuário DESLOGADO
                          console.log("Estado: DESLOGADO.");
                          userId = null; startingAddress = '';
                          if (emailVerificationBar) emailVerificationBar.style.display = 'none';
                          if (appContainer) appContainer.style.display = 'none';
                          if (loginContainer) loginContainer.style.display = 'flex';
                          if(firebaseInitialized) {
                              updateLoginUI(false, "Faça login para salvar e gerenciar suas rotas.");
                          } else {
                              updateLoginUI(false, "Erro na inicialização. Recarregue.", true);
                          }
                          if (deliveriesUnsubscribe) { deliveriesUnsubscribe(); deliveriesUnsubscribe = null; }
                          currentDeliveries = []; lastOptimizedRoute = [];
                      }
                 });
                 // --- FIM: Lógica de Autenticação ---

             } catch (initError) {
                  console.error("Erro CRÍTICO ao inicializar Firebase:", initError);
                  updateLoginUI(false, `Erro Crítico: ${initError.message}. Verifique a config.`, true);
                  if (appContainer) appContainer.style.display = 'none';
                  if (loginContainer) loginContainer.style.display = 'flex';
                  firebaseInitialized = false;
             }
        }); // Fim do DOMContentLoaded


        // Função de Login com Google (usa Popup) (igual)
        window.loginWithGoogle = async () => {
             if (!auth || !firebaseInitialized) return;
             const provider = new GoogleAuthProvider();
             updateLoginUI(true, "Abrindo popup do Google...");
             if (authErrorElement) authErrorElement.style.display = 'none';
             try {
                 const result = await signInWithPopup(auth, provider);
                 console.log("Login com Popup bem-sucedido:", result.user);
                 updateLoginUI(true, "Autenticado com sucesso! Carregando dados...");
             } catch (error) {
                 console.error("Erro ao iniciar signInWithPopup:", error);
                 updateLoginUI(false, `Erro: ${error.code} - ${error.message}`, true);
             }
          };

        // Função para Reenviar Email de Verificação (igual)
        window.resendVerificationEmail = async () => {
             const user = auth.currentUser;
             if (!user) return;
             // await user.reload(); // Remover reload daqui, pode causar loop
             if (user.emailVerified) {
                 if (emailVerificationBar) emailVerificationBar.style.display = 'none';
                 return;
             }
             console.log("Tentando reenviar e-mail de verificação...");
             if (resendVerificationButton) resendVerificationButton.disabled = true;
             if (resendStatusElement) resendStatusElement.textContent = 'Enviando...';
             try {
                 await sendEmailVerification(user);
                 sessionStorage.setItem('verificationEmailSent', Date.now().toString()); // Atualiza timestamp
                 console.log("E-mail de verificação reenviado.");
                 if (resendStatusElement) resendStatusElement.textContent = 'Reenviado!';
                 setTimeout(() => {
                      if (resendVerificationButton) resendVerificationButton.disabled = false;
                      if (resendStatusElement) resendStatusElement.textContent = '';
                 }, 30000); // Espera 30 segundos
             } catch (error) {
                 console.error("Erro ao reenviar e-mail:", error);
                 if (resendStatusElement) resendStatusElement.textContent = `Erro: ${error.code}`;
                 if (resendVerificationButton) resendVerificationButton.disabled = false;
             }
        };


        // Logout (igual)
        window.logout = async () => { if (!auth || !firebaseInitialized) return; try { await signOut(auth); } catch (error) { console.error("Erro ao sair:", error); } };

        // --- Controle de Visualização --- (igual)
        window.showView = (viewId) => {
             console.log("Mudando para view:", viewId);
             currentView = viewId;
             const routeV = document.getElementById('route-view');
             const mgmtV = document.getElementById('management-view');
             if (routeV) routeV.style.display = 'none';
             if (mgmtV) mgmtV.style.display = 'none';

             const targetView = document.getElementById(viewId);
             if (targetView) targetView.style.display = 'block';

             const navRoute = document.getElementById('nav-route');
             const navMgmt = document.getElementById('nav-management');
             if (navRoute) navRoute.classList.toggle('active', viewId === 'route-view');
             if (navMgmt) navMgmt.classList.toggle('active', viewId === 'management-view');

             if (viewId === 'management-view') {
                 renderManagementList(currentDeliveries);
             } else if (firebaseInitialized) {
                 // Re-renderiza a rota atual (otimizada ou básica) sem chamar a API
                 renderRouteList(lastOptimizedRoute, false, {}); // Assumindo que lastOptimizedRoute é mantido
             }
        };

        // --- Funções Firebase --- (iguais)
        function getFirestoreCollection(collectionName) {
             if (!userId || !db) { console.warn(`Firestore indisponível [${collectionName}]`); return null; }
             return collection(db, `users/${userId}/${collectionName}`);
        }
        function getFirestoreDoc(collectionName, docId) {
             const collRef = getFirestoreCollection(collectionName);
             if (!collRef || !docId) return null;
             return doc(collRef, docId);
        }
        function getSettingsDocRef() {
             if (!userId || !db) return null;
             return doc(db, `users/${userId}/config/appSettings`);
        }
        async function saveSettings(settingsData) {
             const docRef = getSettingsDocRef();
             if (!docRef) return;
             try {
                 await setDoc(docRef, settingsData, { merge: true });
                 console.log("Settings saved:", settingsData);
                 if (settingsData.startingAddress !== undefined) startingAddress = settingsData.startingAddress;
             } catch (error) { console.error("Error saving settings:", error); }
        }
        async function loadSettings() {
              const docRef = getSettingsDocRef();
              if (!docRef) return;
              try {
                  const docSnap = await getDoc(docRef);
                  const addressInput = document.getElementById('start-address');
                  if (docSnap.exists()) {
                      const settings = docSnap.data();
                      startingAddress = settings.startingAddress || '';
                      if (addressInput) addressInput.value = startingAddress;
                  } else {
                      startingAddress = '';
                      if (addressInput) addressInput.value = '';
                  }
              } catch (error) { console.error("Error loading settings:", error); startingAddress=''; const el = document.getElementById('start-address'); if(el) el.value=''; }
        }
        window.addDelivery = function() {
              const collRef = getFirestoreCollection('deliveries');
              const cepErrorEl = document.getElementById('cep-error');
              if (!collRef) { if(cepErrorEl){ cepErrorEl.textContent="Erro DB"; cepErrorEl.style.display='block';} return; }
              const addressInput = document.getElementById('address');
              const neighborhoodInput = document.getElementById('neighborhood');
              const sizeInput = document.querySelector('input[name="size"]:checked');
              const cepInput = document.getElementById('cep');
              const address = addressInput.value.trim();
              const neighborhood = neighborhoodInput.value.trim();
              const size = sizeInput ? sizeInput.value : 'Pequeno';
              const cep = cepInput.value.replace(/\D/g, '');
              if (!address || !neighborhood) { if(cepErrorEl){ cepErrorEl.textContent="Endereço e Bairro obrigatórios"; cepErrorEl.style.display='block';} return; }

              // CORREÇÃO: Certifique-se de que o endereço inclui bairro, cidade e estado, se possível
              let fullAddress = address;
              // Tenta extrair cidade/UF do endereço se não estiver lá
              if (!fullAddress.includes(neighborhood)) {
                  fullAddress += `, ${neighborhood}`;
              }
              // Tenta pegar cidade/UF do endereço base se não estiver no endereço da entrega
              const baseAddressInputEl = document.getElementById('start-address');
              const baseAddressValue = baseAddressInputEl ? baseAddressInputEl.value : ''; // Garante que o elemento existe
              const baseMatch = baseAddressValue.match(/,([^,]+-\s*[A-Z]{2})$/); // Tenta pegar ", Cidade - UF" com espaço opcional
              if (baseMatch && !/,\s*[^,]+-\s*[A-Z]{2}$/.test(fullAddress)) {
                   fullAddress += baseMatch[0]; // Adiciona ", Cidade - UF"
              }

              const newDelivery = {
                  address: fullAddress, // Endereço completo melhorado
                  neighborhood,
                  size,
                  cep: cep || null,
                  createdAt: Timestamp.now(),
                  status: 'pending'
              };

              addDoc(collRef, newDelivery)
                   .then(() => {
                       addressInput.value = ''; neighborhoodInput.value = ''; cepInput.value = '';
                       if(cepErrorEl) cepErrorEl.style.display='none';
                       document.querySelector('input[name="size"][value="Pequeno"]').checked = true;
                   })
                   .catch(error => { console.error("Erro ao adicionar:", error); if(cepErrorEl){ cepErrorEl.textContent=`Erro: ${error.message}`; cepErrorEl.style.display='block';} });
        }
        function loadDeliveries() {
              const collRef = getFirestoreCollection('deliveries');
              if (!collRef) { renderRouteList([], true, {}); renderManagementList([]); return; }
              if (deliveriesUnsubscribe) deliveriesUnsubscribe();
              const q = query(collRef, orderBy("createdAt", "desc"));
              deliveriesUnsubscribe = onSnapshot(q, (querySnapshot) => {
                  currentDeliveries = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                  // Dispara a otimização inicial (silenciosa)
                  optimizeAndRenderRoutes(currentDeliveries, true);

                  // Se o usuário estiver na tela de gerenciamento, atualiza ela também
                  if (currentView === 'management-view') {
                      renderManagementList(currentDeliveries);
                  }
              }, (error) => { console.error("Erro loadDeliveries:", error); renderRouteList([], true, {}); renderManagementList([]); });
        }
        window.toggleDeliveryStatus = async (deliveryId, currentStatus) => {
              const docRef = getFirestoreDoc('deliveries', deliveryId); if (!docRef) return;
               let newStatus = (currentStatus === 'pending') ? 'delivered' : (currentStatus === 'delivered' ? 'not_home' : 'pending');
              try { await updateDoc(docRef, { status: newStatus }); }
              catch (error) { console.error("Erro toggleStatus:", error); }
        };

        // deleteDelivery é chamado por handleConfirmDelete
        window.deleteDelivery = function(deliveryId) {
              const docRef = getFirestoreDoc('deliveries', deliveryId); if (!docRef) return;
              // Lógica de confirmação está em handleConfirmDelete
              deleteDoc(docRef).then(() => console.log("Excluído:", deliveryId)).catch(error => console.error("Erro ao excluir:", error));
        };

        // --- Otimização e Rota ---
        window.runOptimization = async function(isInitialLoad = false) {
              const routeStatus = document.getElementById('route-status');
              const optimizeButton = document.getElementById('update-route-button');
              const startAddressInput = document.getElementById('start-address');
              const currentAddressValue = startAddressInput ? startAddressInput.value.trim() : '';

              if (currentAddressValue && currentAddressValue !== startingAddress) {
                  startingAddress = currentAddressValue;
                  await saveSettings({ startingAddress: startingAddress });
              } else if (!startingAddress && currentAddressValue) {
                   startingAddress = currentAddressValue;
                   await saveSettings({ startingAddress: startingAddress });
              }

              if (!isInitialLoad) {
                  console.log("Iniciando otimização manual...");
                  if (routeStatus) { routeStatus.textContent = "Otimizando rota..."; routeStatus.style.display = 'block'; }
                  if (optimizeButton) optimizeButton.disabled = true;
              }

              // Passa o endereço atualizado
              await optimizeAndRenderRoutes(currentDeliveries, isInitialLoad, startingAddress);

              if (!isInitialLoad && optimizeButton) {
                  optimizeButton.disabled = false;
              }
        }

        // ******** INÍCIO DA SEÇÃO MODIFICADA ********
        async function optimizeAndRenderRoutes(allDeliveries, isInitialLoad = false, currentStartAddress = null) {
              const routeStatus = document.getElementById('route-status');
              const startAddr = currentStartAddress !== null ? currentStartAddress : startingAddress; // Usa o mais recente
              const deliveriesToOptimize = allDeliveries.filter(d => d.status === 'pending' || d.status === 'not_home'); // Otimiza pendentes e não estava
              const failedDeliveries = {};

              console.log(`optimizeAndRenderRoutes chamado. isInitialLoad: ${isInitialLoad}, startAddr: ${startAddr}, deliveriesToOptimize: ${deliveriesToOptimize.length}`);

              if (!startAddr && deliveriesToOptimize.length > 0) {
                  console.warn("Endereço de partida não definido. Usando ordenação básica.");
                  if (routeStatus && !isInitialLoad) routeStatus.textContent = "Ordenação básica (Defina um endereço de partida).";
                  const basicSorted = basicSortDeliveries(allDeliveries); // Ordena TODOS para fallback
                  lastOptimizedRoute = basicSorted; // Salva a rota (mesmo básica)
                  renderRouteList(basicSorted, true, {});
                  return;
              } else if (deliveriesToOptimize.length === 0) {
                  console.log("Nenhuma entrega pendente/não em casa para otimizar.");
                  lastOptimizedRoute = []; // Limpa a rota otimizada
                  renderRouteList([], true, {}); // Mostra lista vazia na aba Rota
                  if (routeStatus) routeStatus.style.display = 'none';
                  return;
              }

              if (!isInitialLoad && routeStatus) {
                  routeStatus.textContent = "Buscando coordenadas...";
                  routeStatus.style.display = 'block';
              }

              try {
                  // **REVERSÃO: Chave e Endpoint V1**
                  const apiKey = "5b3ce3597851110001cf624852da619a1e2f42b7984cc26314de2636"; // Chave V1

                  const locations = [startAddr, ...deliveriesToOptimize.map(d => d.address)];
                  const coordinates = [];
                  const geoCache = new Map();

                  for (let i = 0; i < locations.length; i++) {
                      const address = locations[i];
                      const isStart = i === 0;
                      const delivery = isStart ? null : deliveriesToOptimize[i - 1]; // Entrega correspondente
                      const cacheKey = address + (delivery ? delivery.id : 'start'); // Chave única para cache

                      if (geoCache.has(cacheKey)) {
                          coordinates.push(geoCache.get(cacheKey));
                          continue;
                      }
                      if (!isInitialLoad && routeStatus) routeStatus.textContent = `Buscando coord. (${i + 1}/${locations.length})...`;

                      // Delay para não estourar o limite da API (40 reqs/min)
                      await new Promise(resolve => setTimeout(resolve, 1500));

                      try {
                           // **REVERSÃO: Endpoint V1**
                          const geoResponse = await fetch(`https://api.openrouteservice.org/geocode/search?api_key=${apiKey}&text=${encodeURIComponent(address)}`);
                          if (!geoResponse.ok) throw new Error(`Status ${geoResponse.status}`);
                          const geoData = await geoResponse.json();
                          if (!geoData.features || geoData.features.length === 0) throw new Error(`Não encontrado`);

                          const coord = geoData.features[0].geometry.coordinates; // [lon, lat]
                          geoCache.set(cacheKey, coord);
                          coordinates.push(coord);
                      } catch (geoError) {
                          console.error(`Falha ao geocodificar "${address}":`, geoError.message);
                          if (delivery) { // Se falhou para uma entrega, marca como falha
                              failedDeliveries[delivery.id] = {...delivery, error: geoError.message};
                          } else { // Se falhou para o endereço de partida
                              throw new Error(`Falha ao encontrar coordenadas do endereço de partida "${startAddr}". Verifique o endereço.`);
                          }
                          coordinates.push(null); // Adiciona null para manter a contagem de índices
                      }
                  }
                  console.log("Coordenadas obtidas (pode conter nulls):", coordinates);

                  // Filtra entregas que falharam na geocodificação
                  const validDeliveriesWithCoords = deliveriesToOptimize
                       .map((delivery, index) => ({
                           ...delivery,
                           coords: coordinates[index + 1] ? { latitude: coordinates[index + 1][1], longitude: coordinates[index + 1][0] } : null
                       }))
                       .filter(d => d.coords !== null); // Apenas as que têm coordenadas

                  if (validDeliveriesWithCoords.length === 0 && Object.keys(failedDeliveries).length > 0) {
                      // Se TODAS falharam, só renderiza as falhas
                      lastOptimizedRoute = []; // Nenhuma rota válida
                      renderRouteList([], true, failedDeliveries); // Usa modo básico para mostrar falhas
                      if (routeStatus && !isInitialLoad) routeStatus.textContent = "Nenhuma entrega pôde ser localizada.";
                      return;
                  } else if (validDeliveriesWithCoords.length === 0) {
                      // Se não há falhas E não há válidas (lista vazia inicial?), renderiza vazio
                      lastOptimizedRoute = [];
                      renderRouteList([], true, {});
                      if (routeStatus) routeStatus.style.display = 'none';
                      return;
                  }


                  // Otimização (Vizinho Mais Próximo) SOMENTE com as coordenadas válidas
                  if (!isInitialLoad && routeStatus) routeStatus.textContent = `Calculando rota para ${validDeliveriesWithCoords.length} entregas...`;
                  let currentCoords = { latitude: coordinates[0][1], longitude: coordinates[0][0] }; // Ponto de partida
                  let remainingValidDeliveries = [...validDeliveriesWithCoords];
                  let optimizedRoute = [];

                  while (remainingValidDeliveries.length > 0) {
                      let closestDistance = Infinity;
                      let closestIndex = -1;
                      remainingValidDeliveries.forEach((delivery, index) => {
                          const distance = getHaversineDistance(currentCoords, delivery.coords);
                          if (distance < closestDistance) {
                              closestDistance = distance;
                              closestIndex = index;
                          }
                      });
                      const closestDelivery = remainingValidDeliveries.splice(closestIndex, 1)[0];
                      closestDelivery.distanceFromPrevious = closestDistance;
                      optimizedRoute.push(closestDelivery);
                      currentCoords = closestDelivery.coords;
                  }

                  console.log("Rota otimizada:", optimizedRoute);
                  console.log("Entregas com falha na geocodificação:", failedDeliveries);
                  if (routeStatus && !isInitialLoad) {
                      let statusMsg = `Rota otimizada para ${optimizedRoute.length} entregas!`;
                      if (Object.keys(failedDeliveries).length > 0) {
                          statusMsg += ` (${Object.keys(failedDeliveries).length} não localizadas).`;
                      }
                      routeStatus.textContent = statusMsg;
                  } else if (routeStatus) {
                      routeStatus.style.display = 'none'; // Esconde status no load inicial
                  }

                  lastOptimizedRoute = optimizedRoute; // Salva a rota otimizada
                  renderRouteList(optimizedRoute, false, failedDeliveries); // Renderiza otimizada + falhas

              } catch (error) {
                  console.error("Erro durante otimização/geocodificação:", error);
                  if (routeStatus && !isInitialLoad) routeStatus.textContent = `Erro: ${error.message}. Usando ordenação básica.`;
                  const basicSorted = basicSortDeliveries(allDeliveries); // Fallback: ordena TODOS
                  lastOptimizedRoute = basicSorted; // Salva a rota (básica)
                  renderRouteList(basicSorted, true, failedDeliveries); // Mostra falhas mesmo no fallback
              }
        }
        // ******** FIM DA SEÇÃO MODIFICADA ********


        // --- Busca CEP --- (iguais)
        window.fetchAddressByCEP = async function() { /* ... */ }
        window.fetchBaseAddressByCEP = async function() { /* ... */ }
        window.searchCEPsByAddress = async function() { /* ... */ }


        // --- INÍCIO: Funções de Helper e Renderização (Implementadas) --- (iguais)

        // Calcula distância (Haversine)
        function getHaversineDistance(coords1, coords2) {
             function toRad(x) { return x * Math.PI / 180; }
             const R = 6371; // Raio da Terra em km
             const dLat = toRad(coords2.latitude - coords1.latitude);
             const dLon = toRad(coords2.longitude - coords1.longitude);
             const lat1 = toRad(coords1.latitude);
             const lat2 = toRad(coords2.latitude);
             const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                       Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
             const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
             return R * c; // Distância em km
        }

        // Ordenação básica (fallback)
        function basicSortDeliveries(deliveries) {
             // Primeiro, separa por status: pendentes/não-casa, depois entregues
             const pending = deliveries.filter(d => d.status === 'pending' || d.status === 'not_home');
             const delivered = deliveries.filter(d => d.status === 'delivered');

             // Ordena ambos os grupos
             const sortFn = (a, b) => {
                 const bairroA = a.neighborhood.toLowerCase();
                 const bairroB = b.neighborhood.toLowerCase();
                 if (bairroA < bairroB) return -1;
                 if (bairroA > bairroB) return 1;

                 // Se bairros são iguais, ordena por endereço (rua)
                 const addressA = a.address.toLowerCase().replace(/^[^\s]+\s/, ''); // Tenta remover nome da rua
                 const addressB = b.address.toLowerCase().replace(/^[^\s]+\s/, '');
                 return addressA.localeCompare(addressB);
             };

             pending.sort(sortFn);
             delivered.sort(sortFn);

             // Retorna pendentes primeiro, depois entregues
             return [...pending, ...delivered];
        }

        // Renderiza a lista principal de rotas
        function renderRouteList(deliveries, isBasicSort, failedDeliveries) {
             const listElement = document.getElementById('delivery-list');
             const openMapsButton = document.getElementById('open-maps-button');
             if (!listElement || !openMapsButton) return;

             listElement.innerHTML = ''; // Limpa a lista

             if (deliveries.length === 0 && (!failedDeliveries || Object.keys(failedDeliveries).length === 0)) {
                 listElement.innerHTML = '<p class="text-slate-500 text-center">Nenhuma entrega pendente para exibir.</p>';
                 openMapsButton.style.display = 'none';
                 return;
             }

             if (isBasicSort) {
                 // Renderização básica (agrupada por bairro/rua)
                 openMapsButton.style.display = 'none';
                 const grouped = deliveries.reduce((acc, d) => {
                     const bairro = d.neighborhood || 'Sem Bairro';
                     if (!acc[bairro]) acc[bairro] = [];
                     acc[bairro].push(d);
                     return acc;
                 }, {});
                 renderBasicGroup(listElement, grouped, 'route');
             } else {
                 // Renderização otimizada (lista ordenada)
                 openMapsButton.style.display = 'inline-flex';
                 renderOptimizedList(listElement, deliveries);
             }

             // Renderiza falhas, se houver
             if (failedDeliveries && Object.keys(failedDeliveries).length > 0) {
                 renderFailedList(listElement, failedDeliveries);
             }
        }

        // Renderiza a lista de gerenciamento
        function renderManagementList(allDeliveries) {
             const listElement = document.getElementById('management-delivery-list');
             if (!listElement) return;

             listElement.innerHTML = '';

             if (allDeliveries.length === 0) {
                  listElement.innerHTML = '<p class="text-slate-500 text-center">Nenhuma entrega salva.</p>';
                  return;
             }

             // Na tela de gerenciamento, sempre usamos a ordenação básica
             const sorted = basicSortDeliveries(allDeliveries);
             const grouped = sorted.reduce((acc, d) => {
                 const bairro = d.neighborhood || 'Sem Bairro';
                 if (!acc[bairro]) acc[bairro] = [];
                 acc[bairro].push(d);
                 return acc;
             }, {});

             renderBasicGroup(listElement, grouped, 'management');
        }

        // Helper para renderizar lista otimizada (ordenada)
        function renderOptimizedList(listElement, deliveries) {
              const ol = document.createElement('ol');
              ol.className = 'route-list space-y-4';
              deliveries.forEach((delivery, index) => {
                  // Contexto 'route'
                  renderGenericDeliveryItem(ol, delivery, 'route');
              });
              listElement.appendChild(ol);
        }

        // Helper para renderizar lista básica (agrupada)
        function renderBasicGroup(listElement, groupedDeliveries, context) {
              const bairros = Object.keys(groupedDeliveries).sort();

              bairros.forEach(bairro => {
                  const groupDiv = document.createElement('div');
                  groupDiv.className = 'bairro-group';

                  const title = document.createElement('h3');
                  title.textContent = bairro;
                  groupDiv.appendChild(title);

                  // Agrupa por rua dentro do bairro
                  const streets = groupedDeliveries[bairro].reduce((acc, d) => {
                      // Extrai nome da rua (tenta pegar "Rua/Av Nome da Rua")
                      const match = d.address.match(/^([a-zA-Zá-úÁ-Ú\s]+,)\s*\d+/);
                      const streetName = match ? match[1].replace(',', '').trim() : (d.address.split(',')[0] || 'Endereço sem rua');
                      if (!acc[streetName]) acc[streetName] = [];
                      acc[streetName].push(d);
                      return acc;
                  }, {});

                  const streetNames = Object.keys(streets).sort();
                  streetNames.forEach(streetName => {
                      const streetDiv = document.createElement('div');
                      streetDiv.className = 'street-group';

                      const streetTitle = document.createElement('h4');
                      streetTitle.textContent = streetName;
                      streetDiv.appendChild(streetTitle);

                      const ul = document.createElement('ul');
                      ul.className = 'management-list space-y-4'; // Usa classe base

                      // Ordena por número (extrai primeiro número do endereço)
                      streets[streetName].sort((a, b) => {
                          const numA = parseInt(a.address.match(/\d+/)?.[0] || 0);
                          const numB = parseInt(b.address.match(/\d+/)?.[0] || 0);
                          return numA - numB;
                      });

                      streets[streetName].forEach(delivery => {
                          // Passa o nome da rua para não repetir
                          renderGenericDeliveryItem(ul, delivery, context, streetName);
                      });

                      streetDiv.appendChild(ul);
                      groupDiv.appendChild(streetDiv);
                  });
                  listElement.appendChild(groupDiv);
              });
        }

        // Helper para renderizar a lista de falhas
        function renderFailedList(listElement, failedDeliveries) {
              const container = document.createElement('div');
              container.className = 'failed-deliveries-container mt-8';

              const title = document.createElement('h3');
              title.textContent = 'Entregas Não Localizadas';
              title.className = 'text-lg font-semibold text-red-700 border-b border-red-200 pb-2 mb-4 failed-deliveries-title';
              container.appendChild(title);

              const ul = document.createElement('ul');
              ul.className = 'management-list space-y-4'; // Reusa o estilo

              Object.values(failedDeliveries).forEach(delivery => {
                   const li = document.createElement('li');
                   li.className = 'management-list-item border-l-4 border-red-500 bg-red-50';

                   const addressP = document.createElement('p');
                   addressP.innerHTML = `<strong>${delivery.address}</strong>`;
                   li.appendChild(addressP);

                   const bairroP = document.createElement('p');
                   bairroP.textContent = delivery.neighborhood;
                   li.appendChild(bairroP);

                   const errorP = document.createElement('p');
                   errorP.className = 'text-sm text-red-600';
                   errorP.textContent = `Erro: ${delivery.error || 'Não foi possível encontrar as coordenadas.'}`;
                   li.appendChild(errorP);

                   ul.appendChild(li);
              });

              container.appendChild(ul);
              listElement.appendChild(container);
        }

        // Função de renderização de item unificada
        function renderGenericDeliveryItem(parentElement, delivery, context, streetNameIfBasic = null) {
              const li = document.createElement(context === 'route' ? 'li' : 'div'); // li para <ol>, div para <ul>

              // Classes de status
              let itemClasses = (context === 'route') ? 'route-list-item' : 'delivery-item management-list-item';
              if (delivery.status === 'delivered') itemClasses += ' delivered-item';
              if (delivery.status === 'not_home') itemClasses += ' not-home-item';
              li.className = itemClasses;

              const contentDiv = document.createElement('div');

              const addressP = document.createElement('p');
              let addressHtml = `<strong>${delivery.address}</strong>`;

              // Se for agrupado (básico), remove o nome da rua se for igual ao título
              if (streetNameIfBasic && delivery.address.toLowerCase().includes(streetNameIfBasic.toLowerCase())) {
                   addressHtml = `<strong>${delivery.address.replace(new RegExp(streetNameIfBasic + ',?', 'i'), '').trim()}</strong>`;
              }
              addressP.innerHTML = addressHtml;

              // Adiciona tag de tamanho
              const sizeTag = document.createElement('span');
              sizeTag.textContent = delivery.size;
              sizeTag.className = `size-tag ${delivery.size === 'Grande' ? 'size-grande' : 'size-pequeno'}`;
              addressP.querySelector('strong').appendChild(sizeTag);

              contentDiv.appendChild(addressP);

              // Adiciona bairro (se não for agrupado por rua, ou se for rota otimizada)
              if (context === 'route' || !streetNameIfBasic) {
                  const bairroP = document.createElement('p');
                  bairroP.textContent = delivery.neighborhood;
                  contentDiv.appendChild(bairroP);
              }

              // Adiciona distância (apenas para rota otimizada)
              if (context === 'route' && delivery.distanceFromPrevious !== undefined) {
                   const distP = document.createElement('span');
                   distP.className = 'route-distance';
                   distP.textContent = `(~${delivery.distanceFromPrevious.toFixed(2)} km do anterior)`;
                   contentDiv.appendChild(distP);
              }

              li.appendChild(contentDiv);

              // Botões (Status e Excluir)
              const buttonDiv = document.createElement('div');
              buttonDiv.className = 'flex flex-col sm:flex-row gap-2 mt-2 sm:mt-0';

              // Botão de Status
              const statusButton = document.createElement('button');
              statusButton.className = `btn btn-toggle-status ${delivery.status}`;

              let statusText = 'Pendente';
              if (delivery.status === 'delivered') statusText = 'Entregue';
              if (delivery.status === 'not_home') statusText = 'Não Estava';
              statusButton.textContent = statusText;

              statusButton.onclick = () => toggleDeliveryStatus(delivery.id, delivery.status);
              buttonDiv.appendChild(statusButton);

              // Botão Excluir
              const deleteButton = document.createElement('button');
              deleteButton.className = 'btn btn-danger';
              deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="w-4 h-4"><path fill-rule="evenodd" d="M5 3.25V4H2.75a.75.75 0 0 0 0 1.5h.3l.815 8.15A1.5 1.5 0 0 0 5.357 15h5.285a1.5 1.5 0 0 0 1.493-1.35l.815-8.15h.3a.75.75 0 0 0 0-1.5H11v-.75A2.25 2.25 0 0 0 8.75 1h-1.5A2.25 2.25 0 0 0 5 3.25Zm2.25-.75a.75.75 0 0 0-.75.75V4h3v-.75a.75.75 0 0 0-.75-.75h-1.5ZM4.5 5.5l.806 8.058a.1.1 0 0 0 .098.092h5.192a.1.1 0 0 0 .098-.092L11.5 5.5h-7Z" clip-rule="evenodd" /></svg>`;
              deleteButton.onclick = () => handleConfirmDelete(deleteButton, delivery.id);
              buttonDiv.appendChild(deleteButton);

              li.appendChild(buttonDiv);
              parentElement.appendChild(li);
        }

        // Confirmação de exclusão (sem alert)
        function handleConfirmDelete(buttonElement, deliveryId) {
              const originalText = buttonElement.innerHTML;

              // Se já está no modo "Confirmar?"
              if (buttonElement.classList.contains('confirm-delete')) {
                  deleteDelivery(deliveryId);
                  // O onSnapshot vai atualizar a UI
              } else {
                  // Entra no modo "Confirmar?"
                  buttonElement.classList.add('confirm-delete');
                  buttonElement.textContent = 'Confirmar?';

                  // Reseta o botão após 3 segundos
                  setTimeout(() => {
                      if (buttonElement.classList.contains('confirm-delete')) {
                           buttonElement.classList.remove('confirm-delete');
                           buttonElement.innerHTML = originalText;
                      }
                  }, 3000);
              }
        }

        // Abrir Google Maps
        window.openGoogleMaps = function() {
              if (!startingAddress || lastOptimizedRoute.length === 0) {
                  console.warn("Sem endereço de partida ou rota para abrir no Maps.");
                  return;
              }

              const baseUrl = "https://www.google.com/maps/dir/";
              const origin = encodeURIComponent(startingAddress);
              const destination = encodeURIComponent(lastOptimizedRoute[lastOptimizedRoute.length - 1].address);

              const waypoints = lastOptimizedRoute.slice(0, -1) // Todos exceto o último
                                                 .map(d => encodeURIComponent(d.address))
                                                 .join('/');

              let url = `${baseUrl}${origin}/`;
              if (waypoints) {
                  url += `${waypoints}/`;
              }
              url += `${destination}`;

              window.open(url, '_blank');
        }

        // Imprimir
        window.printList = (context) => {
              const body = document.body;
              if (context === 'route') {
                  body.classList.add('printing-route');
                  body.classList.remove('printing-management');
              } else {
                  body.classList.add('printing-management');
                  body.classList.remove('printing-route');
              }
              window.print();
              // Limpa as classes após a impressão (timeout)
              setTimeout(() => {
                   body.classList.remove('printing-route', 'printing-management');
              }, 500);
        };

        // --- FIM: Funções de Helper ---

    </script>
</body>
</html>

